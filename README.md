# 100k_IO_EchoServer
Cpp Network, IOCP

## 초당 10만회의 IO를 수행할 수 있는 에코서버를 만들어보자.
[기존 진행하던 프로젝트](https://github.com/SuhYC/RPGServer)는 C++환경과 C#환경 사이에서의 원활한 네트워크 송수신을 위해 링버퍼를 도입하고, <br/>
패킷 분할을 처리하기 위해 ```[size]```와 같은 헤더를 부착하여 송신하고, 수신 측에서 해당 헤더를 제거하는 작업을 수행했다. <br/>
이 과정에서 ```[size]```와 같은 문자열을 부착하고 처리하는 과정은 상당히 비효율적이다. <br/>
```std::string::find```함수는 결국 문자열의 앞부터 순회하여 해당하는 문자가 발견될 때까지 하나씩 검사하기 때문에 O(N)의 복잡도를 갖는다. <br/>
헤더의 길이는 logN이라고 볼 수 있으니 O(logN)이라고 볼 수도 있지만, 이보다 더 간단하게 헤더처리를 할 수 있다. <br/>

## 송신문자열의 상위 4바이트를 항상 헤더로 고정, unsigned int 데이터를 활용해 길이를 표현.
방법은 간단하다. 송신할 페이로드의 크기를 ```unsigned int``` 형으로 표현하고 <br/>
해당 데이터를 그대로 메모리 복사하여 송신문자열의 상위4바이트로 두고, <br/>
페이로드를 그 뒤에 복사하여 붙이고 전송하는 것. <br/>

아래 그림이 송신큐에 담기 위해 헤더를 부착하는 부분이다. <br/>
![SendQueue.Push](https://github.com/SuhYC/100k_IO_EchoServer/blob/main/push.png)

수신 측에서도 최대한 메모리 복사를 이용해 처리한다. <br/>
상위 4바이트를 ```unsigned int```형 데이터에 메모리 복사하여 페이로드의 크기를 알아내고, <br/>
문자열의 크기가 충분하다면 헤더와 페이로드에 해당하는 부분을 제거하여 <br/>
페이로드는 처리함수로 보내고 남은 문자열은 앞으로 당겨주는 식으로 처리할 수 있다. <br/>

아래 그림이 수신큐에서 처리할 페이로드를 가져오는 부분이다. <br/>
![RecvQueue.Pop](https://github.com/SuhYC/100k_IO_EchoServer/blob/main/HandleHeader.png)

## 측정 방법
클라이언트의 송신큐에 미리 250개 가량의 메시지를 담아두고 시작한다.<br/>
클라이언트의 송수신 스레드는 각 1개씩 사용하며, 서버는 각각의 메시지의 헤더를 제거한 뒤 바로 헤더를 다시 부착하여 클라이언트로 재송신한다. <br/>
클라이언트의 수신스레드가 문자열을 수신하면 헤더를 제거하여 페이로드를 획득할 때마다 송수신 횟수를 1회 증가시킨다. 이후 페이로드는 다시 헤더를 부착하여 서버로 전송한다.<br/>
100만회 송수신이 완료되면 소요된 시간을 출력한다.

## 결과
![결과1](https://github.com/SuhYC/100k_IO_EchoServer/blob/main/1.png) <br/>
![결과2](https://github.com/SuhYC/100k_IO_EchoServer/blob/main/2.png) <br/>
![결과3](https://github.com/SuhYC/100k_IO_EchoServer/blob/main/3.png) <br/>
![결과4](https://github.com/SuhYC/100k_IO_EchoServer/blob/main/4.png) <br/>
![결과5](https://github.com/SuhYC/100k_IO_EchoServer/blob/main/5.png) <br/>

5회 실행 결과는 100만회 기준으로 10226 밀리초, 10375 밀리초, 9800 밀리초, 9710 밀리초, 10451 밀리초가 측정되었다. <br/>
10만회의 송수신에는 평균 1.01124 초가 소요되었다. <br/>
5회의 실행 중 2회의 실행에서는 초당 10만회 이상의 송수신을 하는데 성공하였으며 <br/>
초당 10만회 이상의 송수신을 매 시도마다 하지는 못하더라도 10만회에 근접한 송수신을 성공하는 모습을 보였다.

## 다음 목표
C#과 C++ 사이에서도 이러한 송수신이 가능한지 알아보고 적용해보기
